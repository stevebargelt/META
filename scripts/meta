#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage:
  meta run <pipeline> --project <path> --task "description" [options]
  meta run <pipeline> --project <path> --continue [options]
  meta status [--project <path>] [--run-id <id>]
  meta resume [--project <path>] [--run-id <id>] [options]
  meta abort [--project <path>] [--run-id <id>]
  meta list
  meta doctor [--project <path>]

Options:
  --cli claude|codex     CLI tool to use (default: claude)
  --run-id <id>          Specific run ID
  --unsafe               Add --dangerously-skip-permissions to claude
  --auto-approve         Auto-approve quality gates
  --no-auto-commit       Disable auto-commit after each step
  --research             Enable competitive research step (project pipeline)
  --no-auto-retry        Prompt for retry on failure (default: auto-retry)
  --max-retries <n>      Max retries before abort (default: 3)
  --dry-run              Show pipeline steps without running
  --continue             Continue with existing handoff.md (for follow-on pipelines)

Notes:
  - Pipelines live in workflows/pipelines/*.pipeline
  - By default, failed steps auto-retry up to 3 times then abort
  - Use --no-auto-retry to get interactive retry prompts
  - Use --continue for follow-on pipelines (e.g., .meta/next.pipeline)
USAGE
}

die() {
  echo "$1" >&2
  exit 1
}

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
META_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
LIB_DIR="${SCRIPT_DIR}/meta-lib"

# shellcheck source=/dev/null
source "${LIB_DIR}/workflow.sh"
# shellcheck source=/dev/null
source "${LIB_DIR}/tmux.sh"
# shellcheck source=/dev/null
source "${LIB_DIR}/handoff.sh"
# shellcheck source=/dev/null
source "${LIB_DIR}/agent-run.sh"
# shellcheck source=/dev/null
source "${LIB_DIR}/gate.sh"
# shellcheck source=/dev/null
source "${LIB_DIR}/status.sh"

resolve_project() {
  local project="$1"
  if [[ -z "$project" ]]; then
    project="$(pwd)"
  fi
  if [[ ! -d "$project" ]]; then
    die "Project path not found: $project"
  fi
  (cd "$project" && pwd -P)
}

resolve_pipeline() {
  local pipeline="$1"
  if [[ -z "$pipeline" ]]; then
    die "Pipeline name required"
  fi

  if [[ -f "$pipeline" ]]; then
    printf "%s" "$pipeline"
    return 0
  fi

  if [[ "$pipeline" != *.pipeline ]]; then
    pipeline="${pipeline}.pipeline"
  fi

  local candidate="${META_DIR}/workflows/pipelines/${pipeline}"
  if [[ -f "$candidate" ]]; then
    printf "%s" "$candidate"
    return 0
  fi

  die "Pipeline not found: $pipeline"
}

slugify() {
  local value="$1"
  value="${value//[^a-zA-Z0-9_-]/_}"
  printf "%s" "$value"
}

generate_run_id() {
  local ts
  ts=$(date -u +"%Y-%m-%dT%H-%M-%SZ")
  local rand
  rand=$(printf "%04x" $((RANDOM % 65536)))
  printf "%s-%s" "$ts" "$rand"
}

step_wait() {
  local exit_file="$1"
  local timeout_sec="$2"
  local start
  start=$(date +%s)

  while true; do
    if [[ -f "$exit_file" ]]; then
      local code
      code=$(cat "$exit_file" 2>/dev/null || echo "1")
      if [[ "$code" == "0" ]]; then
        echo "success"
      else
        echo "fail:$code"
      fi
      return 0
    fi

    local now
    now=$(date +%s)
    if (( now - start >= timeout_sec )); then
      echo "timeout"
      return 0
    fi

    sleep 5
  done
}

select_cli() {
  local step_cli="$1"
  local default_cli="$2"

  if [[ -n "$default_cli" ]]; then
    if [[ "$step_cli" == "interactive" ]]; then
      if [[ "$default_cli" == "codex" ]]; then
        step_cli="codex-interactive"
      else
        step_cli="claude-interactive"
      fi
    elif [[ "$step_cli" == "claude-interactive" || "$step_cli" == "codex-interactive" ]]; then
      :
    else
      step_cli="$default_cli"
    fi
  fi

  if [[ "$step_cli" == "interactive" ]]; then
    step_cli="claude-interactive"
  fi

  if [[ -z "$step_cli" || "$step_cli" == "-" ]]; then
    step_cli="${default_cli:-}"
  fi

  if [[ -z "$step_cli" || "$step_cli" == "-" ]]; then
    step_cli="claude"
  fi

  printf "%s" "$step_cli"
}

truncate_text() {
  local text="$1"
  local max_len="$2"

  text="${text//$'\n'/ }"
  text="${text//$'\r'/ }"
  text="${text//$'\t'/ }"

  if (( ${#text} <= max_len )); then
    printf "%s" "$text"
  else
    printf "%s..." "${text:0:max_len}"
  fi
}

format_duration() {
  local total="$1"
  local hours=$((total / 3600))
  local minutes=$(((total % 3600) / 60))
  local seconds=$((total % 60))

  if (( hours > 0 )); then
    printf "%dh %dm %ds" "$hours" "$minutes" "$seconds"
  elif (( minutes > 0 )); then
    printf "%dm %ds" "$minutes" "$seconds"
  else
    printf "%ds" "$seconds"
  fi
}

append_handoff_excerpt() {
  local file="$1"
  local max_lines="${2:-12}"

  if [[ ! -f "$file" ]]; then
    return 0
  fi

  local excerpt
  excerpt=$(tail -n "$max_lines" "$file" 2>/dev/null || true)
  if [[ -z "$excerpt" ]]; then
    return 0
  fi

  printf "%s\n" "$excerpt" | sed 's/^/  /'
}

extract_prompt_paths() {
  local prompt="$1"

  if ! command -v grep >/dev/null 2>&1; then
    return 0
  fi

  printf "%s\n" "$prompt" \
    | grep -oE '([A-Za-z0-9._-]+/)+[A-Za-z0-9._-]+([.][A-Za-z0-9]+)?|[A-Za-z0-9._-]+[.](md|txt|json|yml|yaml|js|ts)' \
    | sort -u 2>/dev/null || true
}

gate_message() {
  local project="$1"
  local run_id="$2"
  local pipeline_file="$3"
  local step_num="$4"
  local agent="$5"
  local cli="$6"
  local prompt="$7"

  local -a lines
  lines+=("QUALITY GATE after step ${step_num} (${agent})")
  if [[ -n "$pipeline_file" ]]; then
    lines+=("Pipeline: ${pipeline_file} (step ${step_num})")
  fi
  if [[ -n "$cli" ]]; then
    lines+=("CLI: ${cli}")
  fi

  if [[ -n "$prompt" ]]; then
    local prompt_snip
    prompt_snip=$(truncate_text "$prompt" 200)
    lines+=("Prompt: ${prompt_snip}")

    local refs
    refs=$(extract_prompt_paths "$prompt")
    if [[ -n "$refs" ]]; then
      lines+=("Referenced in prompt:")
      while IFS= read -r line; do
        lines+=("  - ${line}")
      done <<<"$refs"
    fi
  fi

  local handoff_main="$project/.meta/handoff.md"
  lines+=("Handoff: ${handoff_main}")

  local step_handoff
  step_handoff="$(handoff_step_file "$project" "$step_num")"
  if [[ -f "$step_handoff" ]]; then
    lines+=("Step handoff: ${step_handoff}")
  fi

  local log_file="$project/.meta/steps/$run_id/step-${step_num}.log"
  if [[ -f "$log_file" ]]; then
    lines+=("Log: ${log_file}")
  else
    lines+=("Log: (none)")
  fi

  local exit_file="$project/.meta/steps/$run_id/step-${step_num}.exit"
  if [[ -f "$exit_file" ]]; then
    local exit_code
    exit_code=$(cat "$exit_file" 2>/dev/null || true)
    if [[ -n "$exit_code" ]]; then
      lines+=("Exit: ${exit_file} (${exit_code})")
    else
      lines+=("Exit: ${exit_file}")
    fi
  else
    lines+=("Exit: ${exit_file} (missing)")
  fi

  if command -v git >/dev/null 2>&1 && git -C "$project" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    local git_status
    git_status=$(git -C "$project" status -sb 2>/dev/null || true)
    if [[ -n "$git_status" ]]; then
      lines+=("Git status:")
      while IFS= read -r line; do
        lines+=("  ${line}")
      done <<<"$git_status"
    fi
    lines+=("Diff: git -C \"$project\" diff")
  fi

  local excerpt_file="$handoff_main"
  if [[ -f "$step_handoff" ]]; then
    excerpt_file="$step_handoff"
  fi
  local excerpt
  excerpt="$(append_handoff_excerpt "$excerpt_file" 12 || true)"
  if [[ -n "$excerpt" ]]; then
    lines+=("Handoff excerpt (${excerpt_file}):")
    while IFS= read -r line; do
      lines+=("${line}")
    done <<<"$excerpt"
  fi

  local review_hint="Approve after reviewing: ${handoff_main}"
  if [[ -f "$step_handoff" ]]; then
    review_hint+=", ${step_handoff}"
  fi
  review_hint+=", ${log_file}, git diff"
  lines+=("$review_hint")

  printf "%s\n" "${lines[@]}"
}

pipeline_has_parallel_groups() {
  local i
  for ((i=1; i<=WF_STEP_COUNT; i++)); do
    if [[ -n "${WF_STEP_GROUP[$i]}" ]]; then
      return 0
    fi
  done
  return 1
}

ensure_parallelization_note() {
  local project="$1"
  local pipeline_name="$2"
  local pipeline_file="$3"

  if pipeline_has_parallel_groups; then
    return 0
  fi

  local handoff_main="$project/.meta/handoff.md"
  if [[ -f "$handoff_main" ]]; then
    if grep -q "^## Parallelization Decision" "$handoff_main" 2>/dev/null; then
      return 0
    fi
  fi

  {
    echo ""
    echo "## Parallelization Decision"
    if [[ -n "$pipeline_name" ]]; then
      echo ""
      echo "**Pipeline:** ${pipeline_name}"
    fi
    if [[ -n "$pipeline_file" ]]; then
      echo "**Pipeline file:** ${pipeline_file}"
    fi
    echo "**Parallel groups:** none (no PARALLEL_GROUP entries detected)"
    echo "**Reason:** [Why parallelism is unsafe or not applicable]"
    echo "**Revisit point:** [When to re-evaluate parallelism]"
  } >> "$handoff_main"
}

pipeline_log_file() {
  local project="$1"
  local run_id="$2"
  printf "%s/.meta/steps/%s/pipeline.log" "$project" "$run_id"
}

pipeline_switch() {
  local project="$1"
  local run_id="$2"
  local state_file="$3"

  local next_pipeline="$project/.meta/next.pipeline"
  if [[ ! -f "$next_pipeline" ]]; then
    return 1
  fi

  local stamp
  stamp=$(date -u +"%Y%m%dT%H%M%SZ")
  local saved="$project/.meta/steps/$run_id/next-${stamp}.pipeline"

  mv "$next_pipeline" "$saved"

  if ! workflow_parse "$saved"; then
    echo "Invalid next pipeline: $saved" >&2
    return 2
  fi

  local name
  name="${WF_NAME:-$(basename "$saved" .pipeline)}"

  state_set "$state_file" "pipeline" "$name"
  state_set "$state_file" "pipeline_file" "$saved"
  state_set "$state_file" "current_step" "0"

  local i
  for ((i=1; i<=WF_STEP_COUNT; i++)); do
    state_set "$state_file" "step_${i}" "pending"
  done

  ensure_parallelization_note "$project" "$name" "$saved"

  echo ""
  echo "Switched to pipeline: $name"

  return 0
}

step_launch() {
  local session="$1"
  local project="$2"
  local run_id="$3"
  local step_num="$4"
  local agent="$5"
  local cli="$6"
  local prompt="$7"
  local handoff_file="$8"
  local unsafe_flag="$9"

  if ! agent_prepare_step "$project" "$run_id" "$step_num" "$agent" "$cli" "$prompt" "$handoff_file" "$META_DIR" "$unsafe_flag"; then
    printf "%s" "127" > "$AGENT_EXIT_FILE"
    return 1
  fi

  rm -f "$AGENT_EXIT_FILE" >/dev/null 2>&1 || true
  if [[ "$handoff_file" == *"handoff-step-"* ]]; then
    rm -f "$project/.meta/steps/$run_id/step-${step_num}.merged" >/dev/null 2>&1 || true
  fi

  # Use pane layout: control on top, workers on bottom
  # Creates a new pane in the bottom area for this step
  echo "Step ${step_num} (${agent}). Opening in worker pane..."
  local pane_title="Step ${step_num}: ${agent}"
  tmux_create_worker_pane "$session" "$step_num" "bash \"$AGENT_RUN_FILE\"" "$pane_title"
}

run_step_serial() {
  local session="$1"
  local project="$2"
  local run_id="$3"
  local step_num="$4"
  local agent="$5"
  local cli="$6"
  local prompt="$7"
  local handoff_file="$8"
  local timeout_min="$9"
  local unsafe_flag="${10}"
  local state_file="${11}"

  local retry_count=0
  local max_retries="${META_MAX_RETRIES:-3}"
  local auto_retry="${META_AUTO_RETRY:-1}"

  while true; do
    state_set "$state_file" "current_step" "$step_num"
    state_set "$state_file" "step_${step_num}" "running"

    step_launch "$session" "$project" "$run_id" "$step_num" "$agent" "$cli" "$prompt" "$handoff_file" "$unsafe_flag"

    local wait_result
    wait_result=$(step_wait "$AGENT_EXIT_FILE" "$((timeout_min * 60))")

    if [[ "$wait_result" == "success" ]]; then
      state_set "$state_file" "step_${step_num}" "done"
      echo "Step ${step_num} completed successfully."
      # Auto-commit after successful step
      if [[ "${META_AUTO_COMMIT:-1}" == "1" ]]; then
        if command -v git >/dev/null 2>&1 && git -C "$project" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          if [[ -n "$(git -C "$project" status --porcelain 2>/dev/null)" ]]; then
            git -C "$project" add -A && git -C "$project" commit -m "meta: step ${step_num} (${agent}) complete" --no-verify 2>/dev/null || true
          fi
        fi
      fi
      # Auto-close step pane on success (logs saved to .meta/steps/)
      tmux_remove_worker_pane "$session" "$step_num"
      return 0
    fi

    state_set "$state_file" "step_${step_num}" "failed"
    retry_count=$((retry_count + 1))

    local message
    local log_file="$project/.meta/steps/$run_id/step-${step_num}.log"
    if [[ "$wait_result" == "timeout" ]]; then
      if [[ -f "$log_file" ]]; then
        message="Step ${step_num} (${agent}) timed out. Log: ${log_file}"
      else
        message="Step ${step_num} (${agent}) timed out. Check the tmux step window."
      fi
    else
      if [[ -f "$log_file" ]]; then
        message="Step ${step_num} (${agent}) failed (exit ${wait_result#fail:}). Log: ${log_file}"
      else
        message="Step ${step_num} (${agent}) failed (exit ${wait_result#fail:}). Check the tmux step window."
      fi
    fi

    # Auto-retry logic
    if [[ "$auto_retry" == "1" ]]; then
      if (( retry_count < max_retries )); then
        echo ""
        echo "$message"
        echo "Auto-retrying... (attempt $((retry_count + 1)) of $max_retries)"
        rm -f "$AGENT_EXIT_FILE" >/dev/null 2>&1 || true
        continue
      else
        echo ""
        echo "=========================================="
        echo "PIPELINE ABORTED: Max retries exhausted"
        echo "=========================================="
        echo ""
        echo "Step ${step_num} (${agent}) failed after ${max_retries} attempts."
        echo ""
        echo "Last failure: $message"
        echo ""
        echo "To resume: meta resume --project \"$project\""
        echo "=========================================="
        return 1
      fi
    fi

    # Manual retry prompt (--no-auto-retry)
    local decision
    decision=$(error_prompt "$message")

    case "$decision" in
      retry)
        rm -f "$AGENT_EXIT_FILE" >/dev/null 2>&1 || true
        ;;
      skip)
        state_set "$state_file" "step_${step_num}" "skipped"
        echo "Step ${step_num} skipped."
        return 0
        ;;
      abort)
        echo "Aborting pipeline."
        return 1
        ;;
    esac
  done
}

# Execute a wave containing multiple concurrent parallel groups
execute_wave_concurrent() {
  local session="$1"
  local project="$2"
  local run_id="$3"
  local wave_groups="$4"  # Space-separated "group:start-end" strings
  local state_file="$5"
  local default_cli="$6"
  local unsafe_flag="$7"

  echo ""
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo "üåä Wave with multiple concurrent groups:"
  echo "$wave_groups" | tr ' ' '\n' | sed 's/^/  - /' | sed 's/:/ (steps /' | sed 's/-/ to /' | sed 's/$/)/'
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

  # Phase 1: Launch all groups in wave
  local group_metadata=()
  local group
  for group in $wave_groups; do
    IFS=':' read -r group_name group_range <<< "$group"
    IFS='-' read -r group_start group_end <<< "$group_range"

    echo ""
    echo "üöÄ Launching group: $group_name (steps $group_start-$group_end)"

    # Track group state
    state_set_group "$state_file" "$group_name" "running"

    # Launch all steps in this group
    local j
    for ((j=group_start; j<=group_end; j++)); do
      local step_status
      step_status=$(state_get "$state_file" "step_${j}" 2>/dev/null || echo "pending")
      if [[ "$step_status" != "done" && "$step_status" != "skipped" ]]; then
        local agent="${WF_STEP_AGENT[$j]}"
        local cli=$(select_cli "${WF_STEP_CLI[$j]}" "$default_cli")
        local prompt="${WF_STEP_PROMPT[$j]}"
        local handoff_file
        handoff_file="$(handoff_step_file "$project" "$j")"

        state_set "$state_file" "current_step" "$j"
        state_set "$state_file" "step_${j}" "running"

        step_launch "$session" "$project" "$run_id" "$j" "$agent" "$cli" "$prompt" "$handoff_file" "$unsafe_flag"
      fi
    done

    # Track group metadata for wait phase
    group_metadata+=("$group_name:$group_start-$group_end")
  done

  # Phase 2: Wait for all groups concurrently
  echo ""
  echo "‚è≥ Waiting for all groups to complete..."

  local failed_groups=()
  local completed_steps=()

  for group in "${group_metadata[@]}"; do
    IFS=':' read -r group_name group_range <<< "$group"
    IFS='-' read -r group_start group_end <<< "$group_range"

    echo "  Monitoring group: $group_name"

    # Wait for all steps in this group
    local group_failed=false
    local j
    for ((j=group_start; j<=group_end; j++)); do
      local step_status
      step_status=$(state_get "$state_file" "step_${j}" 2>/dev/null || echo "pending")
      if [[ "$step_status" == "done" || "$step_status" == "skipped" ]]; then
        completed_steps+=("$j")
        continue
      fi

      local timeout_min="${WF_STEP_TIMEOUT[$j]}"
      local exit_file="$project/.meta/steps/$run_id/step-${j}.exit"
      local wait_result
      wait_result=$(step_wait "$exit_file" "$((timeout_min * 60))")

      if [[ "$wait_result" == "success" ]]; then
        state_set "$state_file" "step_${j}" "done"
        completed_steps+=("$j")
        tmux_remove_worker_pane "$session" "$j"
      else
        state_set "$state_file" "step_${j}" "failed"
        group_failed=true
        echo "    ‚ùå Step $j failed: $wait_result"
      fi
    done

    if [[ "$group_failed" == true ]]; then
      failed_groups+=("$group_name")
      state_set_group "$state_file" "$group_name" "failed"
    else
      state_set_group "$state_file" "$group_name" "done"
      echo "  ‚úÖ Group $group_name complete"
    fi
  done

  # Phase 3: Handle failures
  if [[ ${#failed_groups[@]} -gt 0 ]]; then
    echo ""
    echo "‚ö†Ô∏è  Failed groups in wave: ${failed_groups[*]}"
    echo "Other groups may have completed successfully."
    echo "Resume will retry only failed groups."
    return 1
  fi

  # Phase 4: Handle gate steps
  echo ""
  echo "üö™ Processing gates for completed steps..."
  local step
  for step in "${completed_steps[@]}"; do
    if [[ "${WF_STEP_GATE[$step]}" == "gate" ]]; then
      local gate_status
      gate_status=$(state_get "$state_file" "gate_${step}" 2>/dev/null || echo "")
      if [[ "$gate_status" != "done" ]]; then
        local agent="${WF_STEP_AGENT[$step]}"
        local cli_for_gate=$(select_cli "${WF_STEP_CLI[$step]}" "$default_cli")
        local prompt_for_gate="${WF_STEP_PROMPT[$step]}"
        local log_file="$project/.meta/steps/$run_id/step-${step}.log"
        local pipeline
        pipeline=$(state_get "$state_file" "pipeline_file" || echo "")

        local decision
        decision=$(gate_prompt "$(gate_message "$project" "$run_id" "$pipeline" "$step" "$agent" "$cli_for_gate" "$prompt_for_gate")" "$log_file")
        gate_accumulate_wait "$state_file"

        case "$decision" in
          approve)
            state_set "$state_file" "gate_${step}" "done"
            ;;
          retry)
            local handoff_file
            handoff_file="$(handoff_step_file "$project" "$step")"
            local timeout_min="${WF_STEP_TIMEOUT[$step]}"

            if ! run_step_serial "$session" "$project" "$run_id" "$step" "$agent" "$cli_for_gate" "$prompt_for_gate" "$handoff_file" "$timeout_min" "$unsafe_flag" "$state_file"; then
              return 1
            fi
            handoff_merge_step "$project" "$run_id" "$step" "$agent"
            state_set "$state_file" "gate_${step}" "done"
            ;;
          skip)
            state_set "$state_file" "step_${step}" "skipped"
            state_set "$state_file" "gate_${step}" "done"
            ;;
          abort)
            echo "Aborting pipeline."
            return 1
            ;;
        esac
      fi
    fi
  done

  # Phase 5: Merge handoffs from all completed steps
  echo ""
  echo "üìù Merging handoffs from completed steps..."
  for step in "${completed_steps[@]}"; do
    local agent="${WF_STEP_AGENT[$step]}"
    handoff_merge_step "$project" "$run_id" "$step" "$agent"
  done

  # Phase 6: Auto-commit after wave completion
  if [[ "${META_AUTO_COMMIT:-1}" == "1" ]]; then
    if command -v git >/dev/null 2>&1 && git -C "$project" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      if [[ -n "$(git -C "$project" status --porcelain 2>/dev/null)" ]]; then
        local wave_group_names
        wave_group_names=$(echo "$wave_groups" | tr ' ' '\n' | cut -d: -f1 | tr '\n' ' ')
        git -C "$project" add -A && git -C "$project" commit -m "meta: wave complete (${wave_group_names})" --no-verify 2>/dev/null || true
      fi
    fi
  fi

  echo "‚úÖ Wave complete - all groups succeeded"
  return 0
}

control_run() {
  local project=""
  local pipeline=""
  local run_id=""
  local default_cli=""
  local unsafe=false
  local auto_approve=false
  local auto_commit=true
  local research=false
  local auto_retry=true
  local max_retries=3

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project="$2"
        shift 2
        ;;
      --pipeline)
        pipeline="$2"
        shift 2
        ;;
      --run-id)
        run_id="$2"
        shift 2
        ;;
      --cli)
        default_cli="$2"
        shift 2
        ;;
      --unsafe)
        unsafe=true
        shift
        ;;
      --auto-approve)
        auto_approve=true
        shift
        ;;
      --no-auto-commit)
        auto_commit=false
        shift
        ;;
      --research)
        research=true
        shift
        ;;
      --no-auto-retry)
        auto_retry=false
        shift
        ;;
      --max-retries)
        max_retries="$2"
        shift 2
        ;;
      *)
        shift
        ;;
    esac
  done

  project=$(resolve_project "$project")
  pipeline=$(resolve_pipeline "$pipeline")
  [[ -z "$run_id" ]] && die "Run ID required for control"

  workflow_parse "$pipeline"

  # Inject research step if --research flag is set
  if [[ "$research" == true ]]; then
    workflow_inject_research
  fi

  local pipeline_name
  pipeline_name="${WF_NAME:-$(basename "$pipeline" .pipeline)}"
  ensure_parallelization_note "$project" "$pipeline_name" "$pipeline"

  local state_file="$project/.meta/state.${run_id}"
  if [[ ! -f "$state_file" ]]; then
    die "State file not found: $state_file"
  fi

  trap 'echo "Interrupted. State preserved."; state_set "$state_file" "status" "stopped"; exit 130' INT TERM
  state_set "$state_file" "status" "running"

  local session
  session=$(state_get "$state_file" "session" || true)

  local unsafe_flag=""
  if [[ "$unsafe" == true ]]; then
    unsafe_flag="--dangerously-skip-permissions"
  fi
  if [[ "$auto_approve" == true ]]; then
    export META_AUTO_APPROVE=1
  fi
  if [[ "$auto_commit" == false ]]; then
    export META_AUTO_COMMIT=0
  fi
  if [[ "$auto_retry" == true ]]; then
    export META_AUTO_RETRY=1
  fi
  export META_MAX_RETRIES="$max_retries"

  echo "Running pipeline: ${pipeline_name}"
  echo "Project: ${project}"
  echo "Run ID: ${run_id}"
  echo ""

  # Detect waves for parallel execution optimization
  local -A wave_map  # Maps step index to wave info: "wave_num:group_count"
  local waves_output
  waves_output=$(detect_waves)

  if [[ -n "$waves_output" ]]; then
    local wave_num=0
    while IFS= read -r wave_line; do
      if [[ -z "$wave_line" ]]; then
        continue
      fi

      local wave_groups
      IFS='=' read -r _ wave_groups <<< "$wave_line"
      local group_count
      group_count=$(echo "$wave_groups" | wc -w)

      # Mark first step of each group in this wave
      local group
      for group in $wave_groups; do
        IFS=':' read -r group_name group_range <<< "$group"
        IFS='-' read -r group_start group_end <<< "$group_range"
        wave_map[$group_start]="${wave_num}:${group_count}:${wave_groups}"
      done

      wave_num=$((wave_num + 1))
    done <<< "$waves_output"
  fi

  local idx=1
  while [[ "$idx" -le "$WF_STEP_COUNT" ]]; do
    local status
    status=$(state_get "$state_file" "step_${idx}" || echo "pending")

    if [[ "$status" == "running" ]]; then
      local agent
      agent="${WF_STEP_AGENT[$idx]}"
      local exit_file="$project/.meta/steps/$run_id/step-${idx}.exit"
      if [[ -f "$exit_file" ]]; then
        local exit_code
        exit_code=$(cat "$exit_file" 2>/dev/null || echo "1")
        if [[ "$exit_code" == "0" ]]; then
          state_set "$state_file" "step_${idx}" "done"
          status="done"
        else
          state_set "$state_file" "step_${idx}" "failed"
          status="failed"
        fi
      else
        if ! tmux list-windows -t "$session" 2>/dev/null | grep -q "step-${idx}-${agent}"; then
          state_set "$state_file" "step_${idx}" "pending"
          status="pending"
        fi
      fi
    fi

    if [[ "$status" == "done" || "$status" == "skipped" ]]; then
      if [[ "${WF_STEP_GATE[$idx]}" == "gate" ]]; then
        local gate_status
        gate_status=$(state_get "$state_file" "gate_${idx}" || true)
        if [[ "$gate_status" != "done" ]]; then
          local agent
          agent="${WF_STEP_AGENT[$idx]}"
          local cli_for_gate
          cli_for_gate=$(select_cli "${WF_STEP_CLI[$idx]}" "$default_cli")
          local prompt_for_gate
          prompt_for_gate="${WF_STEP_PROMPT[$idx]}"
          local log_file="$project/.meta/steps/$run_id/step-${idx}.log"
          local decision
          decision=$(gate_prompt "$(gate_message "$project" "$run_id" "$pipeline" "$idx" "$agent" "$cli_for_gate" "$prompt_for_gate")" "$log_file")
          gate_accumulate_wait "$state_file"

          case "$decision" in
            approve)
              state_set "$state_file" "gate_${idx}" "done"
              ;;
            retry)
              local cli
              cli=$(select_cli "${WF_STEP_CLI[$idx]}" "$default_cli")
              local prompt
              prompt="${WF_STEP_PROMPT[$idx]}"
              local timeout_min
              timeout_min="${WF_STEP_TIMEOUT[$idx]}"
              local handoff_file="$project/.meta/handoff.md"

              if ! run_step_serial "$session" "$project" "$run_id" "$idx" "$agent" "$cli" "$prompt" "$handoff_file" "$timeout_min" "$unsafe_flag" "$state_file"; then
                return 1
              fi
              state_set "$state_file" "gate_${idx}" "done"
              ;;
            skip)
              state_set "$state_file" "step_${idx}" "skipped"
              state_set "$state_file" "gate_${idx}" "done"
              ;;
            abort)
              echo "Aborting pipeline."
              return 1
              ;;
          esac
        fi
      fi

      idx=$((idx + 1))
      continue
    fi

    local group
    group="${WF_STEP_GROUP[$idx]}"

    if [[ -n "$group" ]]; then
      # Check if this group is part of a multi-group wave
      local wave_info="${wave_map[$idx]:-}"

      if [[ -n "$wave_info" ]]; then
        IFS=':' read -r wave_num group_count wave_groups <<< "$wave_info"

        if [[ "$group_count" -gt 1 ]]; then
          # Multi-group wave - use concurrent execution
          if ! execute_wave_concurrent "$session" "$project" "$run_id" "$wave_groups" "$state_file" "$default_cli" "$unsafe_flag"; then
            echo "Wave execution failed. Check logs and resume when ready."
            return 1
          fi

          # Skip past all groups in this wave
          local last_step_in_wave=0
          local wg
          for wg in $wave_groups; do
            IFS=':' read -r _ wg_range <<< "$wg"
            IFS='-' read -r _ wg_end <<< "$wg_range"
            if [[ "$wg_end" -gt "$last_step_in_wave" ]]; then
              last_step_in_wave=$wg_end
            fi
          done

          idx=$((last_step_in_wave + 1))

          # Check for pipeline switch after wave
          local switch_result
          if pipeline_switch "$project" "$run_id" "$state_file"; then
            pipeline=$(state_get "$state_file" "pipeline_file" || true)
            pipeline_name="${WF_NAME:-$(basename "$pipeline" .pipeline)}"
            idx=1
          else
            switch_result=$?
            if [[ "$switch_result" -eq 2 ]]; then
              return 1
            fi
          fi

          continue
        fi
      fi

      # Single-group wave or no wave info - use existing logic
      local group_start=$idx
      local group_end=$idx
      while [[ "$group_end" -le "$WF_STEP_COUNT" ]]; do
        if [[ "${WF_STEP_GROUP[$group_end]}" == "$group" ]]; then
          group_end=$((group_end + 1))
        else
          break
        fi
      done
      group_end=$((group_end - 1))

      echo "Running parallel group ${group} (steps ${group_start}-${group_end})"

      local launched_steps=()
      local j
      for ((j=group_start; j<=group_end; j++)); do
        local step_status
        step_status=$(state_get "$state_file" "step_${j}" || echo "pending")
        if [[ "$step_status" == "done" || "$step_status" == "skipped" ]]; then
          continue
        fi

        local agent
        agent="${WF_STEP_AGENT[$j]}"
        local cli
        cli=$(select_cli "${WF_STEP_CLI[$j]}" "$default_cli")

        local prompt
        prompt="${WF_STEP_PROMPT[$j]}"
        local timeout_min
        timeout_min="${WF_STEP_TIMEOUT[$j]}"

        local handoff_file
        handoff_file="$(handoff_step_file "$project" "$j")"

        state_set "$state_file" "current_step" "$j"
        state_set "$state_file" "step_${j}" "running"

        step_launch "$session" "$project" "$run_id" "$j" "$agent" "$cli" "$prompt" "$handoff_file" "$unsafe_flag"
        launched_steps+=("$j")
      done

      local failed_steps=()
      local completed_steps=()

      if [[ ${#launched_steps[@]} -gt 0 ]]; then
      local step
      for step in "${launched_steps[@]}"; do
        local timeout_min
        timeout_min="${WF_STEP_TIMEOUT[$step]}"

        local wait_result
        wait_result=$(step_wait "$project/.meta/steps/$run_id/step-${step}.exit" "$((timeout_min * 60))")

        if [[ "$wait_result" == "success" ]]; then
          state_set "$state_file" "step_${step}" "done"
          completed_steps+=("$step")
          # Auto-close step pane on success
          tmux_remove_worker_pane "$session" "$step"
        else
          state_set "$state_file" "step_${step}" "failed"
          failed_steps+=("${step}:${wait_result}")
        fi
      done
      fi

      if [[ ${#failed_steps[@]} -gt 0 ]]; then
      local auto_retry="${META_AUTO_RETRY:-1}"
      local failed_entry
      for failed_entry in "${failed_steps[@]}"; do
        local step_num="${failed_entry%%:*}"
        local reason="${failed_entry#*:}"
        local agent
        agent="${WF_STEP_AGENT[$step_num]}"

        local message
        local log_file="$project/.meta/steps/$run_id/step-${step_num}.log"
        if [[ "$reason" == "timeout" ]]; then
          if [[ -f "$log_file" ]]; then
            message="Step ${step_num} (${agent}) timed out. Log: ${log_file}"
          else
            message="Step ${step_num} (${agent}) timed out. Check the tmux step window."
          fi
        else
          if [[ -f "$log_file" ]]; then
            message="Step ${step_num} (${agent}) failed (exit ${reason#fail:}). Log: ${log_file}"
          else
            message="Step ${step_num} (${agent}) failed (exit ${reason#fail:}). Check the tmux step window."
          fi
        fi

        local decision
        if [[ "$auto_retry" == "1" ]]; then
          # Auto-retry: go straight to retry via run_step_serial (which has retry logic)
          echo ""
          echo "$message"
          echo "Auto-retrying failed parallel step..."
          decision="retry"
        else
          decision=$(error_prompt "$message")
        fi

        case "$decision" in
          retry)
            local cli
            cli=$(select_cli "${WF_STEP_CLI[$step_num]}" "$default_cli")

            local prompt
            prompt="${WF_STEP_PROMPT[$step_num]}"
            local timeout_min
            timeout_min="${WF_STEP_TIMEOUT[$step_num]}"
            local handoff_file
            handoff_file="$(handoff_step_file "$project" "$step_num")"

            if ! run_step_serial "$session" "$project" "$run_id" "$step_num" "$agent" "$cli" "$prompt" "$handoff_file" "$timeout_min" "$unsafe_flag" "$state_file"; then
              return 1
            fi
            completed_steps+=("$step_num")
            ;;
          skip)
            state_set "$state_file" "step_${step_num}" "skipped"
            ;;
          abort)
            echo "Aborting pipeline."
            return 1
            ;;
        esac
      done
      fi

      if [[ ${#completed_steps[@]} -gt 0 ]]; then
      local merged_step
      for merged_step in "${completed_steps[@]}"; do
        local agent
        agent="${WF_STEP_AGENT[$merged_step]}"
        handoff_merge_step "$project" "$run_id" "$merged_step" "$agent"
      done
      fi

      # Auto-commit after parallel group completion
      if [[ "${META_AUTO_COMMIT:-1}" == "1" ]]; then
        if command -v git >/dev/null 2>&1 && git -C "$project" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          if [[ -n "$(git -C "$project" status --porcelain 2>/dev/null)" ]]; then
            git -C "$project" add -A && git -C "$project" commit -m "meta: parallel group ${group} complete" --no-verify 2>/dev/null || true
          fi
        fi
      fi

      if [[ ${#completed_steps[@]} -gt 0 ]]; then
      local gate_step
      for gate_step in "${completed_steps[@]}"; do
        if [[ "${WF_STEP_GATE[$gate_step]}" == "gate" ]]; then
          local agent
          agent="${WF_STEP_AGENT[$gate_step]}"
          local cli_for_gate
          cli_for_gate=$(select_cli "${WF_STEP_CLI[$gate_step]}" "$default_cli")
          local prompt_for_gate
          prompt_for_gate="${WF_STEP_PROMPT[$gate_step]}"
          local log_file="$project/.meta/steps/$run_id/step-${gate_step}.log"
          local decision
          decision=$(gate_prompt "$(gate_message "$project" "$run_id" "$pipeline" "$gate_step" "$agent" "$cli_for_gate" "$prompt_for_gate")" "$log_file")
          gate_accumulate_wait "$state_file"

          case "$decision" in
            approve)
              state_set "$state_file" "gate_${gate_step}" "done"
              ;;
            retry)
              local cli
              cli=$(select_cli "${WF_STEP_CLI[$gate_step]}" "$default_cli")

              local prompt
              prompt="${WF_STEP_PROMPT[$gate_step]}"
              local timeout_min
              timeout_min="${WF_STEP_TIMEOUT[$gate_step]}"
              local handoff_file
              handoff_file="$(handoff_step_file "$project" "$gate_step")"

              if ! run_step_serial "$session" "$project" "$run_id" "$gate_step" "$agent" "$cli" "$prompt" "$handoff_file" "$timeout_min" "$unsafe_flag" "$state_file"; then
                return 1
              fi
              handoff_merge_step "$project" "$run_id" "$gate_step" "$agent"
              state_set "$state_file" "gate_${gate_step}" "done"
              ;;
            skip)
              state_set "$state_file" "step_${gate_step}" "skipped"
              state_set "$state_file" "gate_${gate_step}" "done"
              ;;
            abort)
              echo "Aborting pipeline."
              return 1
              ;;
          esac
        fi
      done
      fi

      local switch_result
      if pipeline_switch "$project" "$run_id" "$state_file"; then
        pipeline=$(state_get "$state_file" "pipeline_file" || true)
        pipeline_name="${WF_NAME:-$(basename "$pipeline" .pipeline)}"
        idx=1
        continue
      else
        switch_result=$?
        if [[ "$switch_result" -eq 2 ]]; then
          return 1
        fi
      fi

      idx=$((group_end + 1))
      continue
    fi

    local agent
    agent="${WF_STEP_AGENT[$idx]}"
    local cli
    cli=$(select_cli "${WF_STEP_CLI[$idx]}" "$default_cli")

    local prompt
    prompt="${WF_STEP_PROMPT[$idx]}"
    local timeout_min
    timeout_min="${WF_STEP_TIMEOUT[$idx]}"

    local handoff_file="$project/.meta/handoff.md"

    if ! run_step_serial "$session" "$project" "$run_id" "$idx" "$agent" "$cli" "$prompt" "$handoff_file" "$timeout_min" "$unsafe_flag" "$state_file"; then
      return 1
    fi

    if [[ "${WF_STEP_GATE[$idx]}" == "gate" ]]; then
      local cli_for_gate
      cli_for_gate=$(select_cli "${WF_STEP_CLI[$idx]}" "$default_cli")
      local prompt_for_gate
      prompt_for_gate="${WF_STEP_PROMPT[$idx]}"
      local log_file="$project/.meta/steps/$run_id/step-${idx}.log"
      local decision
      decision=$(gate_prompt "$(gate_message "$project" "$run_id" "$pipeline" "$idx" "$agent" "$cli_for_gate" "$prompt_for_gate")" "$log_file")
      gate_accumulate_wait "$state_file"

      case "$decision" in
        approve)
          state_set "$state_file" "gate_${idx}" "done"
          ;;
        retry)
          if ! run_step_serial "$session" "$project" "$run_id" "$idx" "$agent" "$cli" "$prompt" "$handoff_file" "$timeout_min" "$unsafe_flag" "$state_file"; then
            return 1
          fi
          state_set "$state_file" "gate_${idx}" "done"
          ;;
        skip)
          state_set "$state_file" "step_${idx}" "skipped"
          state_set "$state_file" "gate_${idx}" "done"
          ;;
        abort)
          echo "Aborting pipeline."
          return 1
          ;;
      esac
    fi

    local switch_result
    if pipeline_switch "$project" "$run_id" "$state_file"; then
      pipeline=$(state_get "$state_file" "pipeline_file" || true)
      pipeline_name="${WF_NAME:-$(basename "$pipeline" .pipeline)}"
      idx=1
      continue
    else
      switch_result=$?
      if [[ "$switch_result" -eq 2 ]]; then
        return 1
      fi
    fi

    idx=$((idx + 1))
  done

  state_set "$state_file" "current_step" "$WF_STEP_COUNT"
  state_set "$state_file" "status" "complete"
  local finished_ts
  finished_ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  local finished_epoch
  finished_epoch="$(date +%s)"
  state_set "$state_file" "finished" "$finished_ts"
  state_set "$state_file" "finished_epoch" "$finished_epoch"
  local started_epoch
  started_epoch=$(state_get "$state_file" "started_epoch" || true)
  local duration_sec=""
  local gate_wait_sec=""
  local exec_sec=""
  if [[ -n "$started_epoch" ]]; then
    duration_sec=$((finished_epoch - started_epoch))
    state_set "$state_file" "duration_sec" "$duration_sec"
    gate_wait_sec=$(state_get "$state_file" "gate_wait_total" 2>/dev/null || echo "0")
    exec_sec=$((duration_sec - gate_wait_sec))
    state_set "$state_file" "exec_sec" "$exec_sec"
  fi
  local pipeline_log
  pipeline_log="$(pipeline_log_file "$project" "$run_id")"
  if [[ -n "$duration_sec" ]]; then
    echo "PIPELINE END: ${finished_ts} (total ${duration_sec}s, exec ${exec_sec}s, gate wait ${gate_wait_sec}s)" >> "$pipeline_log"
  else
    echo "PIPELINE END: ${finished_ts}" >> "$pipeline_log"
  fi
  echo ""
  echo "Pipeline complete."
  if [[ -n "$duration_sec" ]]; then
    local pretty_total
    pretty_total=$(format_duration "$duration_sec")
    local pretty_exec
    pretty_exec=$(format_duration "$exec_sec")
    local pretty_wait
    pretty_wait=$(format_duration "$gate_wait_sec")
    echo "Total duration:     ${pretty_total} (${duration_sec}s)"
    echo "Execution time:     ${pretty_exec} (${exec_sec}s)"
    echo "Gate wait time:     ${pretty_wait} (${gate_wait_sec}s)"
  fi
}

meta_run() {
  local pipeline="$1"
  shift

  local project=""
  local task=""
  local default_cli=""
  local run_id=""
  local unsafe=false
  local auto_approve=false
  local auto_commit=true
  local research=false
  local auto_retry=true
  local max_retries=3
  local dry_run=false
  local continue_mode=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project="$2"
        shift 2
        ;;
      --task)
        task="$2"
        shift 2
        ;;
      --cli)
        default_cli="$2"
        shift 2
        ;;
      --run-id)
        run_id="$2"
        shift 2
        ;;
      --unsafe)
        unsafe=true
        shift
        ;;
      --auto-approve)
        auto_approve=true
        shift
        ;;
      --no-auto-retry)
        auto_retry=false
        shift
        ;;
      --max-retries)
        max_retries="$2"
        shift 2
        ;;
      --no-auto-commit)
        auto_commit=false
        shift
        ;;
      --research)
        research=true
        shift
        ;;
      --dry-run)
        dry_run=true
        shift
        ;;
      --continue)
        continue_mode=true
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        die "Unknown option: $1"
        ;;
    esac
  done

  # Require either --task or --continue
  if [[ -z "$task" && "$continue_mode" == false ]]; then
    die "--task is required (or use --continue for follow-on pipelines)"
  fi

  project=$(resolve_project "$project")
  pipeline=$(resolve_pipeline "$pipeline")

  workflow_parse "$pipeline"

  # Inject research step if --research flag is set
  if [[ "$research" == true ]]; then
    workflow_inject_research
  fi

  local pipeline_name
  pipeline_name="${WF_NAME:-$(basename "$pipeline" .pipeline)}"

  if [[ -z "$run_id" ]]; then
    run_id=$(generate_run_id)
  fi

  local project_base
  project_base=$(basename "$project")
  local session
  session="meta-${project_base}-${run_id}"
  session=$(slugify "$session")

  if [[ "$dry_run" == true ]]; then
    echo "Pipeline: ${pipeline_name}"
    echo "Project: ${project}"
    echo "Run ID: ${run_id}"
    echo ""

    local idx
    for ((idx=1; idx<=WF_STEP_COUNT; idx++)); do
      local agent
      agent="${WF_STEP_AGENT[$idx]}"
      local cli
      cli="${WF_STEP_CLI[$idx]}"
      if [[ -n "$default_cli" ]]; then
        cli="$default_cli"
      fi
      if [[ -z "$cli" || "$cli" == "-" ]]; then
        cli="claude"
      fi
      echo "${idx}. ${agent} (${cli}) gate=${WF_STEP_GATE[$idx]} group=${WF_STEP_GROUP[$idx]:--} timeout=${WF_STEP_TIMEOUT[$idx]}"
      echo "   ${WF_STEP_PROMPT[$idx]}"
    done
    exit 0
  fi

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # PRE-FLIGHT CHECK - Quick validation before launching pipeline
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # Note: This is a quick sanity check. The pipeline itself has verification
  # steps (preflight-gate in step 1, scope-verification after orchestrator).
  # This pre-check catches obvious issues before spinning up tmux.

  if [[ -x "${SCRIPT_DIR}/preflight-gate.sh" ]]; then
    echo ""
    echo "Running pre-flight check..."
    if ! "${SCRIPT_DIR}/preflight-gate.sh" --project "$project" 2>/dev/null; then
      echo ""
      echo "‚ö†Ô∏è  Pre-flight check found issues (see above)."
      echo "   The pipeline will attempt to address these, but you may want to fix them first."
      echo ""
      read -p "Continue anyway? [Y/n] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Nn]$ ]]; then
        die "Aborted. Fix issues before running pipeline."
      fi
    else
      echo "‚úì Pre-flight check passed"
    fi
    echo ""
  fi

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  tmux_require

  local meta_dir="$project/.meta"
  mkdir -p "$meta_dir/steps/$run_id"

  if [[ "$continue_mode" == true ]]; then
    # Continue mode: preserve existing handoff.md and intelligently skip completed steps
    if [[ ! -f "$project/.meta/handoff.md" ]]; then
      die "--continue specified but no handoff.md found in $project/.meta/"
    fi
    echo "Continuing with existing handoff.md"
    echo "Detecting completed phases..."
  else
    # New run: clean up old next.pipeline and initialize handoff
    rm -f "$meta_dir/next.pipeline" >/dev/null 2>&1 || true
    handoff_init "$project" "$task" "$run_id" "$pipeline_name"
    ensure_parallelization_note "$project" "$pipeline_name" "$pipeline"
  fi

  local pipeline_log
  pipeline_log="$(pipeline_log_file "$project" "$run_id")"
  local started_ts
  started_ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  local started_epoch
  started_epoch="$(date +%s)"
  : > "$pipeline_log"
  {
    echo "PIPELINE START: ${started_ts}"
    echo "Project: ${project}"
    echo "Pipeline: ${pipeline_name}"
    echo "Pipeline file: ${pipeline}"
    echo "Run ID: ${run_id}"
  } >> "$pipeline_log"

  local state_file="$meta_dir/state.${run_id}"
  state_set "$state_file" "pipeline" "$pipeline_name"
  state_set "$state_file" "pipeline_file" "$pipeline"
  state_set "$state_file" "session" "$session"
  state_set "$state_file" "started" "$started_ts"
  state_set "$state_file" "started_epoch" "$started_epoch"
  state_set "$state_file" "run_id" "$run_id"
  state_set "$state_file" "current_step" "0"
  state_set "$state_file" "gate_wait_total" "0"

  # Persist CLI flags for resume
  state_set "$state_file" "flag_cli" "$default_cli"
  state_set "$state_file" "flag_unsafe" "$unsafe"
  state_set "$state_file" "flag_auto_approve" "$auto_approve"
  state_set "$state_file" "flag_auto_commit" "$auto_commit"
  state_set "$state_file" "flag_research" "$research"
  state_set "$state_file" "flag_auto_retry" "$auto_retry"
  state_set "$state_file" "flag_max_retries" "$max_retries"

  # Initialize all steps as pending first
  local idx
  for ((idx=1; idx<=WF_STEP_COUNT; idx++)); do
    state_set "$state_file" "step_${idx}" "pending"
  done

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # SMART CONTINUE: Mark completed steps as done based on artifacts
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  if [[ "$continue_mode" == true ]]; then
    echo ""
    echo "Detecting completed steps based on existing artifacts..."

    local skip_to_step=0
    local handoff_file="$project/.meta/handoff.md"

    # For project pipeline, check if planning phases are complete
    if [[ "$pipeline_name" == "project" ]]; then
      # Check multiple indicators that planning is done:
      # 1. "Ready for Build" or "Next Phase: Build" marker
      # 2. Completed phases documented in handoff
      # 3. All required docs exist
      local planning_complete=false

      if grep -q "Ready for Build Pipeline\|Next Phase: Build\|## Completed Phases" "$handoff_file" 2>/dev/null; then
        # Check if PRD and Architecture docs exist
        if [[ -f "$project/docs/PRD.md" && -f "$project/docs/ARCHITECTURE.md" ]]; then
          # Check if external services are documented
          if [[ -f "$project/.env.example" ]]; then
            planning_complete=true
            echo "  ‚úì Planning phases complete (docs + .env.example exist)"
          elif grep -q "External.*[Ss]ervices\|EXTERNAL.*SERVICES" "$handoff_file" 2>/dev/null; then
            planning_complete=true
            echo "  ‚úì Planning phases complete (docs + external services documented)"
          fi
        fi
      fi

      if [[ "$planning_complete" == true ]]; then
        # Mark steps 1-5 as done (preflight, kickoff, PRD, architecture, external services)
        for ((idx=1; idx<=5; idx++)); do
          state_set "$state_file" "step_${idx}" "done"
          echo "  ‚úì Step $idx: Marked as done"
        done
        skip_to_step=6
        echo ""
        echo "‚Üí Continuing from step 6 (orchestrator)"
      else
        echo "  ‚Ñπ Planning phases not detected as complete - starting from beginning"
        echo "     (Need: PRD.md + ARCHITECTURE.md + .env.example or external services doc)"
      fi

    # For feature/bugfix pipelines, check if there's a next.pipeline
    elif [[ -f "$project/.meta/next.pipeline" ]]; then
      echo "  ‚úì Found .meta/next.pipeline"
      echo "  ‚Üí Will execute existing pipeline"
      skip_to_step=1
    fi

    if [[ $skip_to_step -gt 0 ]]; then
      state_set "$state_file" "current_step" "$((skip_to_step - 1))"
    fi
    echo ""
  fi
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  local control_flags=""
  if [[ -n "$default_cli" ]]; then
    control_flags+=" --cli \"$default_cli\""
  fi
  if [[ "$unsafe" == true ]]; then
    control_flags+=" --unsafe"
  fi
  if [[ "$auto_approve" == true ]]; then
    control_flags+=" --auto-approve"
  fi
  if [[ "$auto_commit" == false ]]; then
    control_flags+=" --no-auto-commit"
  fi
  if [[ "$research" == true ]]; then
    control_flags+=" --research"
  fi
  if [[ "$auto_retry" == false ]]; then
    control_flags+=" --no-auto-retry"
  fi
  if [[ "$max_retries" != "3" ]]; then
    control_flags+=" --max-retries $max_retries"
  fi

  local control_script="$meta_dir/steps/$run_id/control.run.sh"
  cat > "$control_script" <<EOF_CTRL
#!/usr/bin/env bash
set -euo pipefail
"$SCRIPT_DIR/meta" --control --project "$project" --pipeline "$pipeline" --run-id "$run_id"${control_flags}
EOF_CTRL
  chmod +x "$control_script" >/dev/null 2>&1 || true

  if tmux_session_exists "$session"; then
    die "Tmux session already exists: $session"
  fi

  tmux_create_session "$session" "control" "bash \"$control_script\""
  tmux_init_layout "$session"
  echo "Created tmux session: $session"
  echo "Layout: Control pane (top), worker panes (bottom)"
  tmux_attach "$session"
}

meta_status() {
  local project=""
  local run_id=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project="$2"
        shift 2
        ;;
      --run-id)
        run_id="$2"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        die "Unknown option: $1"
        ;;
    esac
  done

  project=$(resolve_project "$project")

  local state_file
  if [[ -n "$run_id" ]]; then
    state_file="$project/.meta/state.${run_id}"
  else
    state_file=$(state_latest_file "$project" || true)
  fi

  if [[ -z "$state_file" || ! -f "$state_file" ]]; then
    die "No state file found for project: $project"
  fi

  state_print_summary "$state_file"
}

meta_resume() {
  local project=""
  local run_id=""
  local default_cli=""
  local unsafe=""
  local auto_approve=""
  local auto_commit=""
  local research=""
  local auto_retry=""
  local max_retries=""

  # Track which flags were explicitly set
  local cli_set=false
  local unsafe_set=false
  local auto_approve_set=false
  local auto_commit_set=false
  local research_set=false
  local auto_retry_set=false
  local max_retries_set=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project="$2"
        shift 2
        ;;
      --run-id)
        run_id="$2"
        shift 2
        ;;
      --cli)
        default_cli="$2"
        cli_set=true
        shift 2
        ;;
      --unsafe)
        unsafe=true
        unsafe_set=true
        shift
        ;;
      --auto-approve)
        auto_approve=true
        auto_approve_set=true
        shift
        ;;
      --no-auto-commit)
        auto_commit=false
        auto_commit_set=true
        shift
        ;;
      --research)
        research=true
        research_set=true
        shift
        ;;
      --no-auto-retry)
        auto_retry=false
        auto_retry_set=true
        shift
        ;;
      --max-retries)
        max_retries="$2"
        max_retries_set=true
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        die "Unknown option: $1"
        ;;
    esac
  done

  project=$(resolve_project "$project")

  local state_file
  if [[ -n "$run_id" ]]; then
    state_file="$project/.meta/state.${run_id}"
  else
    state_file=$(state_latest_file "$project" || true)
  fi

  if [[ -z "$state_file" || ! -f "$state_file" ]]; then
    die "No state file found for project: $project"
  fi

  # Restore flags from state (unless explicitly set on command line)
  if [[ "$cli_set" == false ]]; then
    default_cli=$(state_get "$state_file" "flag_cli" || true)
  fi
  if [[ "$unsafe_set" == false ]]; then
    unsafe=$(state_get "$state_file" "flag_unsafe" || echo "false")
  fi
  if [[ "$auto_approve_set" == false ]]; then
    auto_approve=$(state_get "$state_file" "flag_auto_approve" || echo "false")
  fi
  if [[ "$auto_commit_set" == false ]]; then
    auto_commit=$(state_get "$state_file" "flag_auto_commit" || echo "true")
  fi
  if [[ "$research_set" == false ]]; then
    research=$(state_get "$state_file" "flag_research" || echo "false")
  fi
  if [[ "$auto_retry_set" == false ]]; then
    auto_retry=$(state_get "$state_file" "flag_auto_retry" || echo "true")
  fi
  if [[ "$max_retries_set" == false ]]; then
    max_retries=$(state_get "$state_file" "flag_max_retries" || echo "3")
  fi

  # Show restored flags if any were loaded
  local restored=""
  if [[ "$auto_approve" == "true" && "$auto_approve_set" == false ]]; then
    restored+=" --auto-approve"
  fi
  if [[ "$unsafe" == "true" && "$unsafe_set" == false ]]; then
    restored+=" --unsafe"
  fi
  if [[ "$research" == "true" && "$research_set" == false ]]; then
    restored+=" --research"
  fi
  if [[ "$auto_retry" == "false" && "$auto_retry_set" == false ]]; then
    restored+=" --no-auto-retry"
  fi
  if [[ -n "$restored" ]]; then
    echo "Restored flags from state:${restored}"
  fi

  local pipeline
  pipeline=$(state_get "$state_file" "pipeline_file" || true)
  if [[ -z "$pipeline" ]]; then
    die "Pipeline file not recorded in state: $state_file"
  fi

  local session
  session=$(state_get "$state_file" "session" || true)
  if [[ -z "$session" ]]; then
    die "Session name not recorded in state: $state_file"
  fi

  run_id=$(state_get "$state_file" "run_id" || true)
  local meta_dir="$project/.meta"

  local control_flags=""
  if [[ -n "$default_cli" ]]; then
    control_flags+=" --cli \"$default_cli\""
  fi
  if [[ "$unsafe" == true ]]; then
    control_flags+=" --unsafe"
  fi
  if [[ "$auto_approve" == true ]]; then
    control_flags+=" --auto-approve"
  fi
  if [[ "$auto_commit" == false ]]; then
    control_flags+=" --no-auto-commit"
  fi
  if [[ "$research" == true ]]; then
    control_flags+=" --research"
  fi
  if [[ "$auto_retry" == false ]]; then
    control_flags+=" --no-auto-retry"
  fi
  if [[ "$max_retries" != "3" && -n "$max_retries" ]]; then
    control_flags+=" --max-retries $max_retries"
  fi

  local control_script="$meta_dir/steps/$run_id/control.run.sh"
  cat > "$control_script" <<EOF_CTRL
#!/usr/bin/env bash
set -euo pipefail
"$SCRIPT_DIR/meta" --control --project "$project" --pipeline "$pipeline" --run-id "$run_id"${control_flags}
EOF_CTRL
  chmod +x "$control_script" >/dev/null 2>&1 || true

  if tmux_session_exists "$session"; then
    if tmux list-panes -t "$session:0" 2>/dev/null | grep -q "(dead)"; then
      tmux respawn-pane -t "$session:0" -k "bash \"$control_script\""
    fi
    tmux_attach "$session"
    return 0
  fi

  tmux_require

  tmux_create_session "$session" "control" "bash \"$control_script\""
  tmux_init_layout "$session"
  tmux_attach "$session"
}

meta_abort() {
  local project=""
  local run_id=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project="$2"
        shift 2
        ;;
      --run-id)
        run_id="$2"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        die "Unknown option: $1"
        ;;
    esac
  done

  project=$(resolve_project "$project")

  local state_file
  if [[ -n "$run_id" ]]; then
    state_file="$project/.meta/state.${run_id}"
  else
    state_file=$(state_latest_file "$project" || true)
  fi

  if [[ -z "$state_file" || ! -f "$state_file" ]]; then
    die "No state file found for project: $project"
  fi

  local session
  session=$(state_get "$state_file" "session" || true)
  if [[ -n "$session" ]]; then
    tmux_cleanup_layout "$session"
    tmux_kill_session "$session"
  fi

  run_id=$(state_get "$state_file" "run_id" || true)

  if [[ -n "$run_id" ]]; then
    rm -rf "$project/.meta/steps/$run_id" || true
  fi

  rm -f "$state_file" || true

  echo "Aborted pipeline run ${run_id}."
}

meta_list() {
  local pipeline_dir="$META_DIR/workflows/pipelines"
  if [[ ! -d "$pipeline_dir" ]]; then
    die "Pipeline directory not found: $pipeline_dir"
  fi

  local file
  for file in "$pipeline_dir"/*.pipeline; do
    [[ -f "$file" ]] || continue
    if workflow_parse "$file"; then
      local name
      name="${WF_NAME:-$(basename "$file" .pipeline)}"
      local desc
      desc="${WF_DESCRIPTION:-}"
      printf "- %s" "$name"
      if [[ -n "$desc" ]]; then
        printf " ‚Äî %s" "$desc"
      fi
      printf "\n"
    fi
  done
}

meta_doctor() {
  local project=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project) project="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  local ok=true

  echo "=== Global Tools ==="

  if ! command -v tmux >/dev/null 2>&1; then
    echo "  tmux: missing"
    ok=false
  else
    echo "  tmux: ok"
  fi

  if command -v claude >/dev/null 2>&1; then
    echo "  claude: ok"
  else
    echo "  claude: missing"
  fi

  if command -v codex >/dev/null 2>&1; then
    echo "  codex: ok"
  else
    echo "  codex: missing"
  fi

  echo ""
  echo "=== Pipelines ==="

  local pipeline_dir="$META_DIR/workflows/pipelines"
  local file
  for file in "$pipeline_dir"/*.pipeline; do
    [[ -f "$file" ]] || continue
    if workflow_parse "$file"; then
      echo "  $(basename "$file"): ok"
    else
      echo "  $(basename "$file"): invalid"
      ok=false
    fi
  done

  if [[ -n "$project" ]]; then
    project=$(resolve_project "$project")
    echo ""
    echo "=== Project: $project ==="

    # Git repo
    if git -C "$project" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      echo "  git: ok"
    else
      echo "  git: not a repo"
    fi

    # README
    if [[ -f "$project/README.md" ]] && [[ -s "$project/README.md" ]]; then
      echo "  README.md: ok"
    else
      echo "  README.md: missing or empty"
      ok=false
    fi

    # AGENTS.md / CLAUDE.md
    if [[ -f "$project/AGENTS.md" ]]; then
      echo "  AGENTS.md: ok"
    else
      echo "  AGENTS.md: missing"
      ok=false
    fi

    # .env / .env.example
    if [[ -f "$project/.env" ]]; then
      echo "  .env: ok"
    elif [[ -f "$project/.env.example" ]]; then
      echo "  .env: missing (.env.example exists ‚Äî copy and fill it)"
      ok=false
    else
      echo "  .env: no .env or .env.example"
    fi

    # node_modules (if package.json exists)
    if [[ -f "$project/package.json" ]]; then
      if [[ -d "$project/node_modules" ]]; then
        echo "  node_modules: ok"
      else
        echo "  node_modules: missing (run npm install)"
        ok=false
      fi

      # test script
      local has_test
      has_test=$(node -e "const p=require('$project/package.json'); console.log(p.scripts && p.scripts.test && !p.scripts.test.includes('no test specified') ? 'yes' : 'no')" 2>/dev/null || echo "no")
      if [[ "$has_test" == "yes" ]]; then
        echo "  test script: ok"
        if [[ -d "$project/node_modules" ]]; then
          if (cd "$project" && npm test --silent >/dev/null 2>&1); then
            echo "  npm test: passes"
          else
            echo "  npm test: FAILS"
            ok=false
          fi
        else
          echo "  npm test: skipped (no node_modules)"
        fi
      else
        echo "  test script: none configured"
      fi
    fi
  fi

  echo ""
  if [[ "$ok" == false ]]; then
    echo "Some checks failed."
    exit 1
  else
    echo "All checks passed."
  fi
}

main() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 1
  fi

  local cmd="$1"
  shift

  case "$cmd" in
    run)
      [[ $# -lt 1 ]] && die "Pipeline name required"
      meta_run "$@"
      ;;
    status)
      meta_status "$@"
      ;;
    resume)
      meta_resume "$@"
      ;;
    abort)
      meta_abort "$@"
      ;;
    list)
      meta_list
      ;;
    doctor)
      meta_doctor "$@"
      ;;
    --control)
      control_run "$@"
      ;;
    -h|--help)
      usage
      ;;
    *)
      die "Unknown command: $cmd"
      ;;
  esac
}

main "$@"
