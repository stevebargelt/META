# Retrospective: test-app-5 (Expense Tracker)

**Date:** 2026-01-28
**Project:** test-app-5 (Expense Tracker)
**Pipeline:** expense-tracker-build (16 steps)
**Duration:** 85 minutes (5137 seconds)
**Status:** Complete

---

## Summary

Built a full-stack expense tracking application using the META pipeline orchestration system. This was the 5th test run validating new features: auto-retry logic, auto-commit, quality gates, and parallel workstreams with contract-first development.

### Stack
- Backend: Node.js + Express + SQLite (better-sqlite3) + TypeScript
- Frontend: React + Vite + Tailwind CSS + React Query + Recharts
- Testing: Vitest + Testing Library + MSW + Supertest

### Output
- **Lines of code:** ~4,500 TypeScript
- **Tests:** 315 (159 server + 156 client)
- **Coverage:** ~80%
- **Git commits:** 16 (auto-commit per step)

---

## What Worked Well

### 1. Contract-First Development (OpenAPI)

**Observation:** Step 1 created `docs/openapi.yaml` before any implementation. Backend and frontend parallel groups could then work against the shared contract independently.

**Result:** Zero integration issues between backend and frontend. Response envelopes, error formats, and data shapes matched perfectly at merge time.

**Pattern to Keep:** Always create contract stub (OpenAPI or similar) before parallelization. See `prompts/contract-stub.md`.

### 2. Parallel Workstreams

**Structure:**
- `infra` (steps 2-3): Database + Frontend scaffold — 8 min parallel
- `backend` (steps 4-7): 4 API features — ran in parallel after infra
- `frontend` (steps 8-10): 3 UI features — ran in parallel after backend

**Observation:** Parallel groups reduced what would have been ~120 min sequential to ~85 min. The 4-way backend parallelism was particularly effective.

**Pattern to Keep:** Group independent features into parallel workstreams. Use contract to define boundaries.

### 3. Auto-Commit Per Step

**Observation:** Each step auto-committed on success with message `meta: step N (agent) complete`. Created clean history showing exactly what each step produced.

**Result:** 16 commits tracing the full pipeline. Easy to bisect if issues found later. Each step's changes are isolated.

**Pattern to Keep:** Auto-commit should remain the default. `--no-auto-commit` available for edge cases.

### 4. Quality Gate Caught Real Issues

**Observation:** Step 15 (DoD checklist) found 3 blocking issues:
1. Missing root `package.json` for monorepo
2. TypeScript errors in test files
3. Vite config proxy pointing to wrong port

**Result:** Step 16 fixed all issues. Final quality gate passed.

**Learning:** The two-step approach (DoD checklist → quality gate script) is redundant but effective. The checklist catches nuanced issues, the script enforces machine-verifiable gates.

### 5. Observability from Day 1

**Observation:** Step 11 (Polish) added correlation ID middleware before any debugging was needed. Every request gets `X-Correlation-ID` header tracked through to error logs.

**Result:** When investigating step 4 timeout, correlation IDs would have enabled end-to-end tracing.

**Pattern to Keep:** Observability checklist should remain a step, not an afterthought.

---

## What Didn't Work Well

### 1. Step 4 Timeout (Led to Auto-Retry Feature)

**Issue:** Step 4 (Categories API) timed out after 20 minutes. Required manual intervention to retry.

**Root cause:** Likely slow API response or network hiccup during tool calls. The work was actually complete—retry finished in 31 seconds.

**Resolution:** Implemented auto-retry as default behavior:
- `--no-auto-retry` flag if manual control needed
- `--max-retries N` (default 3) before abort
- Clear abort message when max retries exhausted

**Learning:** Transient failures are common in long-running pipelines. Auto-retry with backoff should be default.

### 2. Definition of Done Found Multiple Blockers

**Issue:** Step 15 (DoD) found 3 blocking issues that should have been caught earlier:
1. Root `package.json` missing — CI would fail
2. TypeScript errors in tests — build would fail
3. Vite proxy misconfigured — runtime would fail

**Root cause:** Earlier steps didn't validate that their artifacts composed correctly. Each step passed individually but the whole didn't work.

**Potential fix:** Add an intermediate validation step after parallel merges. Something like `npm run build && npm test` at the workspace root before moving to polish/review stages.

### 3. Test Coverage Not Validated Until Step 12

**Issue:** Coverage target (80%) wasn't verified until the tester step. If coverage was low, significant rework would be needed late in the pipeline.

**Potential fix:** Consider adding lightweight coverage check after each backend/frontend step, or set a minimum "testable" threshold earlier.

### 4. Missing Root .gitignore

**Issue:** No root `.gitignore` file was created. Subdirectories (client/, server/) had their own, but the root did not.

**Risk:** Node modules, .env files, or build artifacts could be committed accidentally.

**Resolution:**
- Added `.gitignore` check to `scripts/quality-gate.sh` (fails if missing)
- Added `.gitignore` scaffold to `scripts/new-project.sh` (created on project init)

---

## Metrics

| Metric | Value |
|--------|-------|
| Total duration | 85 min |
| Steps | 16 |
| Parallel groups | 3 (infra, backend, frontend) |
| Max parallelism | 4 (backend group) |
| Tests written | 315 |
| Test coverage | ~80% |
| Git commits | 16 |
| Lines of code | ~4,500 |
| Retries needed | 1 (step 4) |
| Blocking issues found | 3 (all fixed) |

### Step Timing (approximate from logs)

| Step | Agent | Duration | Notes |
|------|-------|----------|-------|
| 1 | base (contract) | 8 min | OpenAPI spec |
| 2-3 | base (infra) | 8 min parallel | DB + frontend scaffold |
| 4-7 | base (backend) | 37 min parallel | 4 APIs (step 4 required retry) |
| 8-10 | base (frontend) | 10 min parallel | 3 UI features |
| 11 | base (polish) | 5 min | Error handling, observability |
| 12 | tester | 17 min | 315 tests |
| 13 | reviewer | 3 min | Code review gate |
| 14 | documenter | 2 min | README, JSDoc |
| 15 | base (DoD) | 2 min | Found 3 blockers |
| 16 | base (gate) | 2 min | Fixed blockers, all green |

---

## Patterns Validated

1. **Contract-first development** — OpenAPI before parallelization works
2. **Feature-first directory structure** — `features/{domain}/` clean separation
3. **Parallel workstreams** — 3 groups effective for full-stack apps
4. **Auto-commit per step** — Clean history, easy to trace
5. **Two-stage quality gate** — Checklist + script catches different issues
6. **Observability from start** — Correlation IDs added early

---

## Action Items for META

### Implemented During This Run

- [x] Auto-retry with max retries (default 3)
- [x] `--no-auto-retry` flag for manual control
- [x] Clear abort message when retries exhausted

### Implemented After Retrospective

- [x] `.gitignore` check in quality-gate.sh (fails if missing)
- [x] `.gitignore` scaffold in new-project.sh (created on project init)

### Should Implement

- [ ] Intermediate build validation after parallel merge
- [ ] Coverage threshold check earlier in pipeline
- [ ] Consider test-per-feature requirement (test with implementation, not separate step)

### Observations to Track

- Backend 4-way parallelism worked well — could push to 5-6 for larger projects
- 85 min total is reasonable for full-stack app with 315 tests
- Quality gate finding 3 issues is good — means it's doing its job

---

## Conclusion

test-app-5 validates the META pipeline for a non-trivial full-stack application. The contract-first, parallel-workstream approach reduced build time by ~30% compared to sequential. Auto-commit and quality gates provided safety nets that caught issues before completion.

The step 4 timeout incident led to a valuable improvement (auto-retry). The DoD blockers highlight the need for earlier integration validation in future pipeline designs.

**Confidence level:** High. This pipeline structure is ready for production projects.
